"""HCL generator for Jamf Pro resources."""
from typing import Dict, Any, Optional, TYPE_CHECKING
from collections import defaultdict
import json

if TYPE_CHECKING:
    from support_file_handler import SupportFileHandler


class HCLGenerator:
    """Generates Terraform HCL from Jamf Pro resource data."""
    
    def __init__(self, support_file_handler: Optional['SupportFileHandler'] = None):
        """
        Initialize the HCL generator.
        
        Args:
            support_file_handler: Optional handler for file references. When provided,
                                  scripts and profiles will use file() references.
        """
        self.used_names = defaultdict(set)
        self.support_file_handler = support_file_handler
        self.templates = {
            'policies': self._generate_policy_hcl,
            'scripts': self._generate_script_hcl,
            'packages': self._generate_package_hcl,
            'categories': self._generate_category_hcl,
            'buildings': self._generate_building_hcl,
            'config-profiles': self._generate_config_profile_hcl,
            'smart-groups': self._generate_computer_group_hcl,
            'static-groups': self._generate_computer_group_hcl,
            'computer_groups': self._generate_computer_group_hcl,
            'jamf-app-catalog': self._generate_app_catalog_hcl,
        }
    
    def generate_resource_hcl(self, resource_type: str, resource_data: dict, resource_name: Optional[str] = None) -> str:
        """
        Generate HCL for a single resource.
        
        Args:
            resource_type: Type of resource
            resource_data: Full resource data from Jamf API
            resource_name: Optional Terraform resource name (defaults to sanitized name)
            
        Returns:
            HCL string for the resource
        """
        if resource_type not in self.templates:
            return f"# Unsupported resource type: {resource_type}\n"
        
        generator_func = self.templates[resource_type]
        return generator_func(resource_data, resource_name)



    def _generate_app_catalog_hcl(self, app_data: dict, resource_name: Optional[str] = None) -> str:
        """
        Generate HCL for a Jamf App Catalog app (App Installer).
        """
        name = app_data.get('name', 'Unnamed App')
        tf_name = resource_name or self._get_unique_tf_name(name, 'jamfpro_app_installer')
        app_details = app_data.get('app', {})
        bundle_id = app_details.get('bundleId', '')
        version = app_details.get('latestVersion', '')
        
        hcl = [f'# Jamf App Catalog: {name}']
        if bundle_id:
            hcl.append(f'# Bundle ID: {bundle_id}')
        if version:
            hcl.append(f'# Version: {version}')
        
        hcl.append(f'resource "jamfpro_app_installer" "{tf_name}" {{')
        hcl.append(f'  name            = "{name}"')
        hcl.append(f'  enabled         = {str(app_data.get("enabled", True)).lower()}')
        hcl.append(f'  deployment_type = "{app_data.get("deploymentType", "SELF_SERVICE")}"')
        hcl.append(f'  update_behavior = "{app_data.get("updateBehavior", "AUTOMATIC")}"')
        
        # Category (required, -1 if not set)
        category_id = app_data.get('category', {}).get('id', -1)
        hcl.append(f'  category_id     = "{category_id}"')
        
        # Site (required, -1 if not set)
        site_id = app_data.get('site', {}).get('id', -1)
        hcl.append(f'  site_id         = "{site_id}"')
        
        # Smart group (required, default to 1 = All Managed Clients)
        smart_group = app_data.get('smartGroup', {})
        smart_group_id = smart_group.get('id', 1)
        if smart_group_id and smart_group.get('name'):
            sg_name = self._sanitize_name(smart_group['name'])
            hcl.append(f'  smart_group_id  = jamfpro_computer_group_smart.{sg_name}.id')
        else:
            hcl.append(f'  smart_group_id  = "1"  # All Managed Clients')
        
        hcl.append('}')
        
        return '\n'.join(hcl)
    
    def generate_file(self, resources_sorted: list) -> str:
        """
        Generate complete .tf file with all resources in dependency order.
        
        Args:
            resources_sorted: List of (resource_type, resource_data) tuples
            
        Returns:
            Complete HCL file content
        """
        hcl_blocks = []
        hcl_blocks.append("# Generated by JamfTerraform Proporter\n")
        hcl_blocks.append("# Contains Jamf Pro resources exported from your instance\n\n")
        
        for resource_type, resource_data in resources_sorted:
            hcl = self.generate_resource_hcl(resource_type, resource_data)
            hcl_blocks.append(hcl)
            hcl_blocks.append("\n")
        
        return "\n".join(hcl_blocks)
    
    def _sanitize_name(self, name: str) -> str:
        """Convert resource name to valid Terraform identifier."""
        # Replace spaces and special chars with underscores
        sanitized = name.lower().replace(' ', '_').replace('-', '_')
        # Remove any non-alphanumeric chars except underscores
        sanitized = ''.join(c if c.isalnum() or c == '_' else '' for c in sanitized)
        # Ensure it starts with a letter
        if sanitized and not sanitized[0].isalpha():
            sanitized = 'r_' + sanitized
        return sanitized or 'unnamed_resource'

    def _get_unique_tf_name(self, name: str, resource_type: str) -> str:
        """
        Get a unique Terraform resource name for the given type.
        Resolves collisions by appending _1, _2, etc.
        """
        base_name = self._sanitize_name(name)
        candidate = base_name
        counter = 1
        
        while candidate in self.used_names[resource_type]:
            candidate = f"{base_name}_{counter}"
            counter += 1
            
        self.used_names[resource_type].add(candidate)
        return candidate
    
    def _generate_policy_hcl(self, policy_data: dict, resource_name: Optional[str] = None) -> str:
        """Generate HCL for a Jamf Pro policy."""
        general = policy_data.get('general', {})
        name = general.get('name', 'Unnamed Policy')
        tf_name = resource_name or self._get_unique_tf_name(name, 'jamfpro_policy')
        
        hcl = [f'resource "jamfpro_policy" "{tf_name}" {{']
        hcl.append(f'  name    = "{name}"')
        hcl.append(f'  enabled = {str(general.get("enabled", True)).lower()}')
        
        # Category
        category = general.get('category', {})
        if isinstance(category, dict) and category.get('id', -1) not in [-1, 0]:
             if category.get('name'):
                cat_name = self._sanitize_name(category.get('name', ''))
                hcl.append(f'  category_id = jamfpro_category.{cat_name}.id')
             else:
                hcl.append(f'  category_id = {category["id"]}')
        
        # Frequency
        if 'frequency' in general:
            hcl.append(f'  frequency = "{general["frequency"]}"')
        
        # Scope
        scope = policy_data.get('scope', {})
        if scope:
            hcl.append('')
            hcl.append('  scope {')
            hcl.append(f'    all_computers = {str(scope.get("all_computers", False)).lower()}')
            
            # Computer groups (Hybrid: Refs + Raw IDs)
            group_targets = []
            
            # 1. From 'computer_groups' (Objects)
            for g in scope.get('computer_groups', []):
                 if isinstance(g, dict):
                      if g.get('name'):
                           group_targets.append(f'jamfpro_computer_group.{self._sanitize_name(g["name"])}.id')
                      elif g.get('id'):
                           group_targets.append(str(g['id']))

            # 2. From 'computer_group_ids' (Flat list)
            for gid in scope.get('computer_group_ids', []):
                 group_targets.append(str(gid))

            if group_targets:
                hcl.append(f'    computer_group_ids = [{", ".join(group_targets)}]')
            
            hcl.append('  }')
        
        # Packages
        packages = policy_data.get('package_configuration', {}).get('packages', [])
        if packages:
            hcl.append('')
            for pkg in packages:
                if isinstance(pkg, dict):
                    hcl.append('  package {')
                    if pkg.get('name'):
                        pkg_name = self._sanitize_name(pkg['name'])
                        hcl.append(f'    id     = jamfpro_package.{pkg_name}.id')
                    else:
                        hcl.append(f'    id     = {pkg.get("id")}')
                    
                    hcl.append(f'    action = "{pkg.get("action", "Install")}"')
                    hcl.append('  }')

        # Scripts
        scripts = policy_data.get('scripts', [])
        if scripts:
            hcl.append('')
            hcl.append('  payloads {')
            for script in scripts:
                if isinstance(script, dict):
                    hcl.append('    scripts {')
                    if script.get('name'):
                        script_name = self._sanitize_name(script['name'])
                        hcl.append(f'      id       = jamfpro_script.{script_name}.id')
                    else:
                        hcl.append(f'      id       = {script.get("id")}')
                        
                    hcl.append(f'      priority = "{script.get("priority", "After")}"')
                    
                    for i in range(4, 12):
                        param_key = f'parameter{i}'
                        if param_key in script and script[param_key]:
                            # Escape quotes in parameter values
                            param_value = script[param_key].replace('"', '\\"')
                            hcl.append(f'      {param_key} = "{param_value}"')
                    
                    hcl.append('    }')
            hcl.append('  }')
        
        hcl.append('}')
        return '\n'.join(hcl)
    
    def _generate_script_hcl(self, script_data: dict, resource_name: Optional[str] = None) -> str:
        """Generate HCL for a Jamf Pro script."""
        name = script_data.get('name', 'Unnamed Script')
        tf_name = resource_name or self._get_unique_tf_name(name, 'jamfpro_script')
        script_id = script_data.get('id')
        
        hcl = [f'resource "jamfpro_script" "{tf_name}" {{']
        hcl.append(f'  name     = "{name}"')
        hcl.append(f'  priority = "{script_data.get("priority", "BEFORE")}"')
        
        # Check if we have a file reference from support_file_handler
        file_ref = None
        if self.support_file_handler and script_id:
            file_ref = self.support_file_handler.get_terraform_file_reference('scripts', script_id)
        
        if file_ref:
            # Use file() reference to external file
            hcl.append(f'  script_contents = {file_ref}')
        elif 'script_contents' in script_data:
            # Fallback: inline content with escaping
            script_contents = script_data['script_contents'].replace('\\', '\\\\').replace('"', '\\"').replace('$', '\\$')
            hcl.append(f'  script_contents = "{script_contents}"')
        else:
            hcl.append('  script_contents = "# Script contents not available"')
        
        # Category reference
        if 'category' in script_data:
            category = script_data['category']
            if isinstance(category, dict) and category.get('id', -1) not in [-1, 0]:
                cat_name = self._sanitize_name(category.get('name', ''))
                hcl.append(f'  category_id = jamfpro_category.{cat_name}.id')
        
        # Optional fields
        if script_data.get('info'):
            info = script_data['info'].replace('"', '\\"')
            hcl.append(f'  info  = "{info}"')
        
        if script_data.get('notes'):
            notes = script_data['notes'].replace('"', '\\"')
            hcl.append(f'  notes = "{notes}"')
        
        if script_data.get('os_requirements'):
            hcl.append(f'  os_requirements = "{script_data["os_requirements"]}"')
        
        # Script parameters (4-11)
        for i in range(4, 12):
            param_key = f'parameter{i}'
            if script_data.get(param_key):
                hcl.append(f'  {param_key} = "{script_data[param_key]}"')
        
        hcl.append('}')
        return '\n'.join(hcl)
    
    def _generate_package_hcl(self, package_data: dict, resource_name: Optional[str] = None) -> str:
        """
        Generate HCL for a Jamf Pro package.
        
        Note: Package files (.pkg, .dmg) are typically very large and are NOT downloaded.
        The user must manually place the package file in the support_files/packages/ directory.
        """
        name = package_data.get('name', 'Unnamed Package')
        tf_name = resource_name or self._get_unique_tf_name(name, 'jamfpro_package')
        filename = package_data.get('filename', f'{tf_name}.pkg')
        
        # Build the expected local path for the package file
        package_path = f'${{path.module}}/support_files/packages/{filename}'
        
        hcl = [f'# Package: {name}']
        hcl.append(f'# NOTE: You must manually place the package file at: support_files/packages/{filename}')
        hcl.append(f'resource "jamfpro_package" "{tf_name}" {{')
        hcl.append(f'  package_name        = "{name}"')
        hcl.append(f'  package_file_source = "{package_path}"')
        
        # Required fields from provider schema
        hcl.append(f'  priority              = {package_data.get("priority", 10)}')
        hcl.append(f'  reboot_required       = {str(package_data.get("reboot_required", False)).lower()}')
        hcl.append(f'  fill_user_template    = {str(package_data.get("fill_user_template", False)).lower()}')
        hcl.append(f'  fill_existing_users   = {str(package_data.get("fill_existing_users", False)).lower()}')
        hcl.append(f'  os_install            = {str(package_data.get("os_install", False)).lower()}')
        hcl.append(f'  suppress_updates      = {str(package_data.get("suppress_updates", False)).lower()}')
        hcl.append(f'  suppress_from_dock    = {str(package_data.get("suppress_from_dock", False)).lower()}')
        hcl.append(f'  suppress_eula         = {str(package_data.get("suppress_eula", False)).lower()}')
        hcl.append(f'  suppress_registration = {str(package_data.get("suppress_registration", False)).lower()}')
        
        # Optional fields
        if package_data.get('category'):
            cat_name = self._sanitize_name(package_data['category'])
            hcl.append(f'  category_id = jamfpro_category.{cat_name}.id')
        
        if package_data.get('info'):
            info = package_data['info'].replace('"', '\\"')
            hcl.append(f'  info  = "{info}"')
        
        if package_data.get('notes'):
            notes = package_data['notes'].replace('"', '\\"')
            hcl.append(f'  notes = "{notes}"')
        
        if package_data.get('os_requirements'):
            hcl.append(f'  os_requirements = "{package_data["os_requirements"]}"')
        
        hcl.append('}')
        return '\n'.join(hcl)
    
    def _generate_category_hcl(self, category_data: dict, resource_name: Optional[str] = None) -> str:
        """Generate HCL for a Jamf Pro category."""
        name = category_data.get('name', 'Unnamed Category')
        tf_name = resource_name or self._get_unique_tf_name(name, 'jamfpro_category')
        
        hcl = [f'resource "jamfpro_category" "{tf_name}" {{']
        hcl.append(f'  name = "{name}"')
        
        if 'priority' in category_data:
            hcl.append(f'  priority = {category_data["priority"]}')
        
        hcl.append('}')
        return '\n'.join(hcl)
    
    def _generate_building_hcl(self, building_data: dict, resource_name: Optional[str] = None) -> str:
        """Generate HCL for a Jamf Pro building."""
        name = building_data.get('name', 'Unnamed Building')
        tf_name = resource_name or self._get_unique_tf_name(name, 'jamfpro_building')
        
        hcl = [f'resource "jamfpro_building" "{tf_name}" {{']
        hcl.append(f'  name = "{name}"')
        
        if 'street_address1' in building_data:
            hcl.append(f'  street_address1 = "{building_data["street_address1"]}"')
        
        if 'city' in building_data:
            hcl.append(f'  city = "{building_data["city"]}"')
        
        hcl.append('}')
        return '\n'.join(hcl)
    
    def _generate_config_profile_hcl(self, profile_data: dict, resource_name: Optional[str] = None) -> str:
        """Generate HCL for a macOS configuration profile."""
        general = profile_data.get('general', {})
        name = general.get('name', 'Unnamed Profile')
        tf_name = resource_name or self._get_unique_tf_name(name, 'jamfpro_macos_configuration_profile_plist')
        profile_id = general.get('id') or profile_data.get('id')
        
        hcl = [f'resource "jamfpro_macos_configuration_profile_plist" "{tf_name}" {{']
        hcl.append(f'  name                = "{name}"')
        
        # Required fields
        description = general.get('description', '')
        if description:
            desc_escaped = description.replace('"', '\\"').replace('\n', '\\n')
            hcl.append(f'  description         = "{desc_escaped}"')
        else:
            hcl.append(f'  description         = "Exported from Jamf Pro"')
        
        # Distribution method and level
        dist_method = general.get('distribution_method', 'Install Automatically')
        hcl.append(f'  distribution_method = "{dist_method}"')
        
        level = general.get('level', 'System')
        # Normalize level value
        if level.lower() in ['computer', 'system', 'device']:
            level = 'System'
        elif level.lower() == 'user':
            level = 'User'
        hcl.append(f'  level               = "{level}"')
        
        # Optional settings
        hcl.append(f'  redeploy_on_update  = "{general.get("redeploy_on_update", "Newly Assigned")}"')
        hcl.append(f'  user_removable      = {str(general.get("user_removable", False)).lower()}')
        
        # Category reference
        category = general.get('category', {})
        if isinstance(category, dict) and category.get('id', -1) not in [-1, 0]:
            cat_name = self._sanitize_name(category.get('name', ''))
            hcl.append(f'  category_id         = jamfpro_category.{cat_name}.id')
        
        # Payloads - check for file reference first
        file_ref = None
        if self.support_file_handler and profile_id:
            file_ref = self.support_file_handler.get_terraform_file_reference('config-profiles', profile_id)
        
        if file_ref:
            # Use file() reference to external .mobileconfig file
            hcl.append(f'  payloads            = {file_ref}')
        elif 'payloads' in general:
            # Fallback: inline heredoc (may have issues with special characters)
            hcl.append('  payloads            = <<-EOF')
            payload_lines = general['payloads'].splitlines()
            for line in payload_lines:
                hcl.append(f'    {line}')
            hcl.append('  EOF')
        else:
            hcl.append('  # Note: payloads not found or require manual configuration')
            hcl.append('  payloads            = ""')
        
        # Scope block (minimal default)
        scope = profile_data.get('scope', {})
        hcl.append('')
        hcl.append('  scope {')
        hcl.append(f'    all_computers = {str(scope.get("all_computers", True)).lower()}')
        hcl.append(f'    all_jss_users = {str(scope.get("all_jss_users", False)).lower()}')
        hcl.append('  }')
        
        hcl.append('}')
        return '\n'.join(hcl)
    
    def _generate_computer_group_hcl(self, group_data: dict, resource_name: Optional[str] = None) -> str:
        """Generate HCL for a computer group (static or smart)."""
        name = group_data.get('name', 'Unnamed Group')
        is_smart = group_data.get('is_smart', False)
        
        resource_type = "jamfpro_computer_group_smart" if is_smart else "jamfpro_computer_group_static"
        tf_name = resource_name or self._get_unique_tf_name(name, resource_type)
        
        hcl = [f'resource "{resource_type}" "{tf_name}" {{']
        hcl.append(f'  name = "{name}"')
        
        if is_smart and 'criteria' in group_data:
            for criterion in group_data['criteria']:
                if isinstance(criterion, dict):
                    hcl.append('  criteria {')
                    hcl.append(f'    name = "{criterion.get("name", "")}"')
                    hcl.append(f'    priority = {criterion.get("priority", 0)}')
                    hcl.append(f'    and_or = "{criterion.get("and_or", "and")}"')
                    hcl.append(f'    search_type = "{criterion.get("search_type", "is")}"')
                    hcl.append(f'    value = "{criterion.get("value", "")}"')
                    hcl.append(f'    opening_paren = {str(criterion.get("opening_paren", False)).lower()}')
                    hcl.append(f'    closing_paren = {str(criterion.get("closing_paren", False)).lower()}')
                    hcl.append('  }')
        
        hcl.append('}')
        return '\n'.join(hcl)
